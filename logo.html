<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Logo 3D PS — Rotação com Sombra</title>
  <style>
    html, body { height: 100%; margin: 0; background: radial-gradient(#1f1f1f, #0f0f0f); overflow: hidden; }
    #app { position: fixed; inset: 0; }
    .hud { position: fixed; left: 12px; bottom: 12px; padding: 10px 12px; border-radius: 12px; backdrop-filter: blur(6px); background: rgba(255,255,255,.08); color: #eaeaea; font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial; display: flex; gap: 10px; align-items: center; }
    .hud label { opacity: .85; }
    .hud input[type="range"] { width: 140px; }
    .hud button { cursor: pointer; border: none; padding: 6px 10px; border-radius: 10px; background: #2b6fff; color: white; font-weight: 600; }
    .tests { position: fixed; right: 12px; bottom: 12px; padding: 8px 10px; border-radius: 10px; background: rgba(0,0,0,.5); color: #cfe8cf; font: 12px/1.2 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre; max-width: 40vw; }
  </style>

  <!-- Import map corrige o erro de "module specifier 'three'" mapeando para um caminho absoluto acessível -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="app"></div>
  <div class="hud">
    <label for="speed">Velocidade</label>
    <input id="speed" type="range" min="-3" max="3" step="0.1" value="1" />
    <button id="toggle">Pausar</button>
  </div>
  <div id="tests" class="tests">running tests…</div>

  <script type="module">
    // Agora usamos os nomes mapeados pelo import map (sem caminhos relativos quebrados)
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

    const app = document.getElementById('app');
    const testsEl = document.getElementById('tests');

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    app.appendChild(renderer.domElement);

    // Cena e câmera
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0.8, 1.1, 4.5);

    // Controles (opcional para inspecionar)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.minDistance = 3;
    controls.maxDistance = 8;

    // Luz ambiente suave
    scene.add(new THREE.AmbientLight(0xffffff, 0.35));

    // Luz direcional com sombras
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.05);
    dirLight.position.set(3, 5, 4);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    dirLight.shadow.camera.near = 0.5;
    dirLight.shadow.camera.far = 20;
    dirLight.shadow.radius = 4; // sombras mais suaves
    scene.add(dirLight);

    // Plano para receber sombra
    const groundGeo = new THREE.PlaneGeometry(20, 20);
    const groundMat = new THREE.ShadowMaterial({ opacity: 0.35 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Grupinho para centralizar o texto
    const group = new THREE.Group();
    scene.add(group);

    // Material metálico/azulado
    const material = new THREE.MeshStandardMaterial({
      color: 0x2a66ff,
      metalness: 0.8,
      roughness: 0.25,
      envMapIntensity: 1.0
    });

    // Carregar fonte (helvetiker)
    const loader = new FontLoader();
    loader.load(
      'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json',
      (font) => {
        const textGeo = new TextGeometry('PS', {
          font,
          size: 1.4,
          height: 0.35,       // profundidade (extrusão)
          curveSegments: 12,
          bevelEnabled: true,
          bevelThickness: 0.06,
          bevelSize: 0.045,
          bevelOffset: 0,
          bevelSegments: 5,
        });
        textGeo.computeBoundingBox();
        textGeo.center(); // centraliza no (0,0,0)

        const textMesh = new THREE.Mesh(textGeo, material);
        textMesh.castShadow = true;
        textMesh.receiveShadow = false;
        group.add(textMesh);

        // luz de preenchimento sutil para highlights
        const rim = new THREE.PointLight(0x88aaff, 0.6, 10);
        rim.position.set(-2.5, 1.5, 3);
        scene.add(rim);

        // --- Testes pós-carregamento da fonte (smoke tests) ---
        runTests({ renderer, scene, camera, group, textMesh });
      },
      undefined,
      (err) => {
        console.error('Falha ao carregar a fonte:', err);
        testsEl.textContent = 'TEST FAIL: fonte não carregou (verifique conexão/CDN).';
      }
    );

    // Responsividade
    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onResize);

    // UI: velocidade e pausa
    const speedEl = document.getElementById('speed');
    const toggleEl = document.getElementById('toggle');

    let speed = parseFloat(speedEl.value);
    let paused = false;

    speedEl.addEventListener('input', () => { speed = parseFloat(speedEl.value); });
    toggleEl.addEventListener('click', () => {
      paused = !paused;
      toggleEl.textContent = paused ? 'Retomar' : 'Pausar';
    });

    // Loop de animação
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      if (!paused) group.rotation.y += dt * (speed * 0.8); // rotação suave
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // =====================
    // Testes mínimos (smoke)
    // =====================
    function runTests(ctx) {
      const results = [];
      try {
        console.assert(ctx.renderer instanceof THREE.WebGLRenderer, 'renderer é WebGLRenderer');
        results.push('renderer OK');

        console.assert(ctx.camera.isPerspectiveCamera, 'camera é PerspectiveCamera');
        results.push('camera OK');

        console.assert(ctx.renderer.shadowMap.enabled === true, 'shadowMap habilitado');
        results.push('shadowMap ON');

        console.assert(ctx.group.children.length > 0, 'grupo possui filhos (texto)');
        results.push('texto carregado');

        console.assert(ctx.textMesh.castShadow === true, 'texto lança sombra');
        results.push('sombra no texto ON');

        testsEl.textContent = 'TEST PASS\n' + results.map((r, i) => `${i+1}. ${r}`).join('\n');
      } catch (e) {
        console.error(e);
        testsEl.textContent = 'TEST FAIL: ' + (e?.message || e);
      }
    }
  </script>
</body>
</html>
